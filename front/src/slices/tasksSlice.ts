import { createAsyncThunk, createSlice, EnhancedStore } from "@reduxjs/toolkit";
// import { ITask } from 'common/inetrfaces/Wallet';
import { RootState } from "../app/store";
// import { HANDLE_TASK } from 'common/constants';
// import { IpcType } from 'common/inetrfaces/Wallet';

const HANDLE_TASK = "HANDLE_TASK";
const ipcRenderer = window as any; //.electron.ipcRenderer;

export interface TasksState {
  tasks: any;
  status: "idle" | "loading" | "failed";
}

const initialState: TasksState = {
  tasks: [],
  status: "idle",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.

export const getTaskAsync = createAsyncThunk("tasks/get", async () => {
  const response = await ipcRenderer.invoke("task-add", {});
  // The value we return becomes the `fulfilled` action payload
  return response;
});

export const addTaskAsync = createAsyncThunk("task/add", async (task) => {
  console.log("GOOOO?", task);
  const response = await ipcRenderer.invoke(HANDLE_TASK, {
    // type: IpcType.Add,
    data: task,
  });

  console.log("AAAAAA", response);

  return response;
});

export const deleteTaskAsync = createAsyncThunk(
  "task/delete",
  async (id: any) => {
    const ok = await ipcRenderer.invoke(HANDLE_TASK, {
      // type: IpcType.Delete,
      data: id,
    });

    if (!ok) return;

    return id;
  }
);

export const startTaskAsync = createAsyncThunk(
  "task/start",
  async (tasks: any) => {
    const response = await ipcRenderer.invoke(HANDLE_TASK, { ids: tasks });
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const stopTaskAsync = createAsyncThunk(
  "task/stop",
  async (tasks: any) => {
    const response = await ipcRenderer.invoke(HANDLE_TASK, { ids: tasks });
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const counterSlice = createSlice({
  name: "task",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    init: (state, action) => {
      console.log(state, action);
      state.tasks = action.payload;
    },
    up: (state, action) => {
      const task = action.payload;
      const index = state.tasks.findIndex((x: any) => x.id == task.id);
      if (index == -1) return;
      state.tasks.splice(index, 1, task);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(addTaskAsync.pending, (state) => {
        state.status = "loading";
      })
      .addCase(addTaskAsync.fulfilled, (state, action: any) => {
        state.status = "idle";
        state.tasks.push(action.payload);
      })
      .addCase(addTaskAsync.rejected, (state) => {
        state.status = "failed";
      })
      .addCase(deleteTaskAsync.pending, (state) => {
        state.status = "loading";
      })
      .addCase(deleteTaskAsync.fulfilled, (state, action: any) => {
        state.status = "idle";
        const id = action.payload;
        state.tasks = state.tasks.filter((x: any) => x.id != id);
      })
      .addCase(deleteTaskAsync.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export const { up, init } = counterSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const allTasks = (state: RootState) => state.tasks.tasks;

// class Tasklice {
//   async init(store: EnhancedStore) {
//     this.update(store);
//     const response = await ipcRenderer.invoke(HANDLE_TASK, {
//       type: IpcType.All,
//     });

//     store.dispatch(init(response));
//   }

//   async update(store: EnhancedStore) {
//     ipcRenderer.on('task-up', (task: any) => {
//       store.dispatch(up(task));
//     });
//   }
// }

// export const taskSliceCls = new Tasklice();

export default counterSlice.reducer;
